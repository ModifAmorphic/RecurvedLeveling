scn rcvSetLevelCurve

int o
int i
array_var skill
array_var lvlUpMult
string_var levelUpMultSetting
array_var useIncKvp
array_var ruseOverrides
array_var skillUseIncs
array_var skillUseInc
string_var useReasons
;inputs
array_var levelCurve
array_var useOverrides
array_var useOverride
Begin _Function { levelCurve useOverrides }
	set i to 0
	DebugPrint "recurve: Setting iLevelUpMults from %g to %g." levelCurve["iLevelUpMults"][0]["value"] levelCurve["iLevelUpMults"][9]["value"]
	while (i < ar_Size levelCurve["iLevelUpMults"])
		let lvlUpMult := levelCurve["iLevelUpMults"][i]
		if (i < 9)
			let levelUpMultSetting := sv_Construct "iLevelUp0%gMult" (i + 1)
		else
			let levelUpMultSetting := "iLevelUp10Mult"
		endif
		SetNumericGameSetting $levelUpMultSetting lvlUpMult["value"]
		;DebugPrint "recurve: Set %z to %g." levelUpMultSetting lvlUpMult["value"]
		let i += 1
	loop
	sv_Destruct levelUpMultSetting
	if (Recurved.AllExperienceMultiplier != 1)
		DebugPrint "recurve: Recurved.AllExperienceMultiplier is set to a value other than 1. Multiplying all skill use increments by %g." Recurved.AllExperienceMultiplier
		set i to 12
		while (i < 33)
			SetSkillUseIncrementC (Recurved.DefaultSkillUseIncrements[i][0] * Recurved.AllExperienceMultiplier) i 0
			SetSkillUseIncrementC (Recurved.DefaultSkillUseIncrements[i][1] * Recurved.AllExperienceMultiplier) i 1
			let i += 1
		loop
	endif
	set i to 0
	while (i < ar_Size levelCurve["skills"])
		let skill := levelCurve["skills"][i]
		if Eval (skill["softCapEnabled"] == 1)
			SetSkillUseIncrementC skill["softCapUseInc"][0] skill["skillCode"] 0
			SetSkillUseIncrementC skill["softCapUseInc"][1] skill["skillCode"] 1
			DebugPrint "recurve: Applied softcap to skill %g. Set useInc0=%.4f, useInc1=%.4f." skill["skillCode"] skill["softCapUseInc"][0] skill["softCapUseInc"][1]
		endif
		let i += 1
	loop
	DebugPrint "recurve: Set iLevelUpSkillCount to %g." levelCurve["iLevelUpSkillCount"]
	SetNumericGameSetting "iLevelUpSkillCount" levelCurve["iLevelUpSkillCount"]
	set i to 0

	if Eval ((ar_Size useOverrides) < 1)
		DebugPrint "recurve: No Use Exp Overrides currently configured."
		return
	endif

	; ###  Skill Use Overrides Processing  ###
	;; Skill Use is processed in manual order. If more SkillUseOverrideReasons are added in the future, this should probably be reworked
	;; to a function to avoid copy/pasting these entire loops over and over
	let skillUseIncs := ar_Construct "Array"
	; Add any weapon overrides first
	let ruseOverrides := call rcvFindSkillUseOverrides useOverrides (Recurved.SkillUseOverrideReasons["Weapon"])
	set o to 0
	;foreach (useKvp <- ruseOverrides)
	;	let useOverride := useKvp["value"]
	DebugPrint "recurve: Creating %g Weapon exp overrides." (ar_Size ruseOverrides)
	while (o < ar_Size ruseOverrides)
		let useOverride := ruseOverrides[o]
		let skillUseInc := ar_Construct "StringMap"
		let skillUseInc["skillCode"] := useOverride["skillCode"]
		let skillUseInc["useIncs"] := ar_Construct "Array"
		let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
		let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
		let skillUseInc["reasons"] := ar_Construct "Array"
		let skillUseInc["reasons"][0] := Recurved.SkillUseOverrideReasons["Weapon"]
		ar_Append skillUseIncs skillUseInc
		let o += 1
	loop

	; modify 
	set o to 0
	let ruseOverrides := call rcvFindSkillUseOverrides useOverrides Recurved.SkillUseOverrideReasons["AttributeProtection"]
	; foreach (useKvp <- ruseOverrides)
	; 	let useOverride := useKvp["value"]
	DebugPrint "recurve: Creating %g AttributeProtection exp overrides." (ar_Size ruseOverrides)
	while (o < ar_Size ruseOverrides)
		let useOverride := ruseOverrides[o]
		let skillUseInc := ar_Construct "StringMap"
		set i to 0
		; foreach (useIncKvp <- skillUseIncs)
		while (i < ar_Size skillUseIncs)
			if Eval(skillUseIncs[i]["skillCode"] == useOverride["skillCode"])
				let skillUseInc := skillUseIncs[i]
			endif
			let i += 1
		loop
		if Eval((ar_Size skillUseInc) < 1)
			; If use increment was not added in an earlier foreach, then add it now with the current calculated use experience values for Attribute Protection
			let skillUseInc["skillCode"] := useOverride["skillCode"]
			let skillUseInc["useIncs"] := ar_Construct "Array"
			let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
			let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
			let skillUseInc["reasons"] := ar_Construct "Array"
			let skillUseInc["reasons"][0] := Recurved.SkillUseOverrideReasons["AttributeProtection"]
			ar_Append skillUseIncs skillUseInc
		else
			; If use increment was added in an earlier foreach, then apply the Attribute Protection use modifiers to the existing modified use experience amounts
			let skillUseInc["useIncs"][0] := call rcvCalculateUseIncrement (skillUseInc["useIncs"][0]) (useOverride["useIncModifiers"][0])
			let skillUseInc["useIncs"][1] := call rcvCalculateUseIncrement (skillUseInc["useIncs"][1]) (useOverride["useIncModifiers"][1])
			ar_Append (skillUseInc["reasons"]) (Recurved.SkillUseOverrideReasons["AttributeProtection"])
		endif
		let o += 1
	loop

	set i to 0
	set o to 0
	let ruseOverrides := call rcvFindSkillUseOverrides useOverrides Recurved.SkillUseOverrideReasons["Overlevel"]
	DebugPrint "recurve: Creating %g Overlevel exp overrides." (ar_Size ruseOverrides)
	; foreach (useKvp <- ruseOverrides)
	; 	let useOverride := useKvp["value"]
	while (o < ar_Size ruseOverrides)
		let useOverride := ruseOverrides[o]
		let skillUseInc := ar_Construct "StringMap"
		foreach (useIncKvp <- skillUseIncs)
			if Eval(useIncKvp["value"]["skillCode"] == useOverride["skillCode"])
				let skillUseInc := useIncKvp["value"]
			endif
		loop
		if Eval((ar_Size skillUseInc) < 1)
			; If use increment was not added in an earlier foreach, then add it now.
			let skillUseInc["skillCode"] := useOverride["skillCode"]
			ar_Append skillUseIncs skillUseInc
		endif
		; regardless of whether or not the skill was already added, overwrite previous modifications with overlevel mods
		let skillUseInc["useIncs"] := ar_Construct "Array"
		let skillUseInc["reasons"] := ar_Construct "Array"
		let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
		let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
		let skillUseInc["reasons"][0] := Recurved.SkillUseOverrideReasons["Overlevel"]
		let o += 1
	loop

	; Finally apply the calculated experience use increments
	set o to 0
	DebugPrint "recurve: Applying %g use increment experience overrides." (ar_Size ruseOverrides)
	; foreach (useKvp <- skillUseIncs)
	; 	let skillUseInc := useKvp["value"]
	while (o < ar_Size skillUseIncs)
		let skillUseInc := skillUseIncs[o]
		SetSkillUseIncrementC skillUseInc["useIncs"][0] skillUseInc["skillCode"] 0
		SetSkillUseIncrementC skillUseInc["useIncs"][1] skillUseInc["skillCode"] 1
		set i to 0
		while (i < ar_Size skillUseInc["reasons"])
			if (i == 0)
				let useReasons := sv_Construct "%g" (skillUseInc["reasons"][i])
			else
				let useReasons := sv_Construct "%z, %g" useReasons (skillUseInc["reasons"][i])
			endif
			let i += 1
		loop
		let o += 1
		DebugPrint "recurve: Overrode skill %g use increments for reason(s) %z. Set useInc0=%.4f, useInc1=%.4f." (skillUseInc["skillCode"]) useReasons (skillUseInc["useIncs"][0]) (skillUseInc["useIncs"][1])
		sv_Destruct useReasons
	loop
	set o to 0
	set i to 0
End