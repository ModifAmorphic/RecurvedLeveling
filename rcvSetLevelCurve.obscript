scn rcvSetLevelCurve

int o
int i
int reason
array_var skill
array_var lvlUpMult
string_var levelUpMultSetting
array_var ruseOverrides
int overrideCount
array_var skillUseIncs
array_var skillUseInc
string_var useReasons
;array_var useIncKvp
;inputs
array_var levelCurve
array_var useOverrides
array_var useOverride
Begin _Function { levelCurve useOverrides }
	set i to 0
	DebugPrint "recurve: Setting iLevelUpMults from %g to %g." levelCurve["iLevelUpMults"][0]["value"] levelCurve["iLevelUpMults"][9]["value"]
	while (i < ar_Size levelCurve["iLevelUpMults"])
		let lvlUpMult := levelCurve["iLevelUpMults"][i]
		if (i < 9)
			let levelUpMultSetting := sv_Construct "iLevelUp0%gMult" (i + 1)
		else
			let levelUpMultSetting := "iLevelUp10Mult"
		endif
		SetNumericGameSetting $levelUpMultSetting lvlUpMult["value"]
		;DebugPrint "recurve: Set %z to %g." levelUpMultSetting lvlUpMult["value"]
		let i += 1
	loop
	sv_Destruct levelUpMultSetting
	set i to 0
	while (i < ar_Size levelCurve["skills"])
		let skill := levelCurve["skills"][i]
		if Eval (skill["softCapEnabled"] == 1)
			SetSkillUseIncrementC skill["softCapUseInc"][0] skill["skillCode"] 0
			SetSkillUseIncrementC skill["softCapUseInc"][1] skill["skillCode"] 1
			DebugPrint "recurve: Applied softcap to skill %g. Set useInc0=%.4f, useInc1=%.4f." skill["skillCode"] skill["softCapUseInc"][0] skill["softCapUseInc"][1]
		endif
		let i += 1
	loop
	DebugPrint "recurve: Set iLevelUpSkillCount to %g." levelCurve["iLevelUpSkillCount"]
	SetNumericGameSetting "iLevelUpSkillCount" levelCurve["iLevelUpSkillCount"]
	set i to 0

	if Eval ((ar_Size useOverrides) < 1)
		DebugPrint "recurve: No Use Exp Overrides currently configured."
		return
	endif

	; ###  Skill Use Overrides Processing  ###
	;; Skill Use is processed in manual order. If more SkillUseOverrideReasons are added in the future, this should probably be reworked
	;; to a function to avoid copy/pasting these entire loops over and over
	let skillUseIncs := ar_Construct "Array"

	set reason to Recurved.OverrideReasonRunning
	while (reason >= Recurved.OverrideReasonOverlevel)
		let ruseOverrides := call rcvFindSkillUseOverrides useOverrides reason
		let overrideCount := ar_Size ruseOverrides

		if (Recurved.DebugEnabled)
			if (reason == Recurved.OverrideReasonRunning)
				DebugPrint "recurve: Found %g exp overrides for override type %g (Running)." overrideCount reason
			elseif (reason == Recurved.OverrideReasonWeapon)
				DebugPrint "recurve: Found %g exp overrides for override type %g (Weapon)." overrideCount reason
			elseif (reason == Recurved.OverrideReasonAttributeGuard)
				DebugPrint "recurve: Found %g exp overrides for override type %g (AttributeGuard)." overrideCount reason
			elseif (reason == Recurved.OverrideReasonFailsafe)
				DebugPrint "recurve: Found %g exp overrides for override type %g (Failsafe)." overrideCount reason
			elseif (reason == Recurved.OverrideReasonOverlevel)
				DebugPrint "recurve: Found %g exp overrides for override type %g (OverLevel)." overrideCount reason
			endif
		endif
		
		set o to 0
		while (o < overrideCount)
			let useOverride := ruseOverrides[o]
			let skillUseInc := ar_Construct "StringMap"
			set i to 0
			while (i < ar_Size skillUseIncs)
				if Eval(skillUseIncs[i]["skillCode"] == useOverride["skillCode"])
					let skillUseInc := skillUseIncs[i]
				endif
				let i += 1
			loop
			if Eval((ar_Size skillUseInc) < 1)
				; If use increment was not added in an earlier foreach, then add it now with the current calculated use experience values for Attribute Protection
				let skillUseInc["skillCode"] := useOverride["skillCode"]
				let skillUseInc["useIncs"] := ar_Construct "Array"
				let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
				let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
				let skillUseInc["reasons"] := ar_Construct "Array"
				let skillUseInc["reasons"][0] := reason
				ar_Append skillUseIncs skillUseInc
			elseif (reason != Recurved.OverrideReasonOverlevel)
				; If use increment was added in an earlier foreach, then apply the Attribute Protection use modifiers to the existing modified use experience amounts
				let skillUseInc["useIncs"][0] := skillUseInc["useIncs"][0] * useOverride["useIncModifiers"][0]
				let skillUseInc["useIncs"][1] := skillUseInc["useIncs"][1] * useOverride["useIncModifiers"][1]
				ar_Append skillUseInc["reasons"] reason
			else
				; regardless of whether or not the skill was already added, overwrite previous modifications with overlevel mods
				let skillUseInc["useIncs"] := ar_Construct "Array"
				let skillUseInc["reasons"] := ar_Construct "Array"
				let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
				let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
				let skillUseInc["reasons"][0] := Recurved.OverrideReasonOverlevel
				ar_Append skillUseIncs skillUseInc
			endif
			let o += 1
		loop
		let reason -= 1
	loop

	; Apply the calculated experience use increments
	set o to 0
	DebugPrint "recurve: Applying %g use increment experience overrides." (ar_Size skillUseIncs)
	; foreach (useKvp <- skillUseIncs)
	; 	let skillUseInc := useKvp["value"]
	while (o < ar_Size skillUseIncs)
		let skillUseInc := skillUseIncs[o]
		SetSkillUseIncrementC skillUseInc["useIncs"][0] skillUseInc["skillCode"] 0
		SetSkillUseIncrementC skillUseInc["useIncs"][1] skillUseInc["skillCode"] 1
		set i to 0
		while (i < ar_Size skillUseInc["reasons"])
			if (i == 0)
				let useReasons := sv_Construct "%g" (skillUseInc["reasons"][i])
			else
				let useReasons := sv_Construct "%z, %g" useReasons (skillUseInc["reasons"][i])
			endif
			let i += 1
		loop
		let o += 1
		DebugPrint "recurve: Overrode skill %v {%g} use increments for reason(s) %z. Set useInc0=%.4f, useInc1=%.4f." (skillUseInc["skillCode"]) (skillUseInc["skillCode"]) useReasons (skillUseInc["useIncs"][0]) (skillUseInc["useIncs"][1])
		sv_Destruct useReasons
	loop
End

	; ; Add any weapon overrides first
	; let ruseOverrides := call rcvFindSkillUseOverrides useOverrides (Recurved.OverrideReasonWeapon)
	; set o to 0
	; ;foreach (useKvp <- ruseOverrides)
	; ;	let useOverride := useKvp["value"]
	; DebugPrint "recurve: Found %g Weapon exp overrides." (ar_Size ruseOverrides)
	; while (o < ar_Size ruseOverrides)
	; 	let useOverride := ruseOverrides[o]
	; 	let skillUseInc := ar_Construct "StringMap"
	; 	let skillUseInc["skillCode"] := useOverride["skillCode"]
	; 	let skillUseInc["useIncs"] := ar_Construct "Array"
	; 	let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
	; 	let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
	; 	let skillUseInc["reasons"] := ar_Construct "Array"
	; 	let skillUseInc["reasons"][0] := Recurved.OverrideReasonWeapon
	; 	ar_Append skillUseIncs skillUseInc
	; 	let o += 1
	; loop

	; let ruseOverrides := call rcvFindSkillUseOverrides useOverrides Recurved.OverrideReasonRunning
	; set o to 0
	; DebugPrint "recurve: Found %g Athletics Run exp overrides." (ar_Size ruseOverrides)
	; while (o < ar_Size ruseOverrides)
	; 	let useOverride := ruseOverrides[o]
	; 	let skillUseInc := ar_Construct "StringMap"
	; 	let skillUseInc["skillCode"] := useOverride["skillCode"]
	; 	let skillUseInc["useIncs"] := ar_Construct "Array"
	; 	let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
	; 	let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
	; 	let skillUseInc["reasons"] := ar_Construct "Array"
	; 	let skillUseInc["reasons"][0] := Recurved.OverrideReasonRunning
	; 	ar_Append skillUseIncs skillUseInc
	; 	let o += 1
	; loop

	; ; Attribute Guard 
	; set o to 0
	; let ruseOverrides := call rcvFindSkillUseOverrides useOverrides Recurved.OverrideReasonAttributeGuard
	; ; foreach (useKvp <- ruseOverrides)
	; ; 	let useOverride := useKvp["value"]
	; DebugPrint "recurve: Found %g AttributeGuard exp overrides." (ar_Size ruseOverrides)
	; while (o < ar_Size ruseOverrides)
	; 	let useOverride := ruseOverrides[o]
	; 	let skillUseInc := ar_Construct "StringMap"
	; 	set i to 0
	; 	; foreach (useIncKvp <- skillUseIncs)
	; 	while (i < ar_Size skillUseIncs)
	; 		if Eval(skillUseIncs[i]["skillCode"] == useOverride["skillCode"])
	; 			let skillUseInc := skillUseIncs[i]
	; 		endif
	; 		let i += 1
	; 	loop
	; 	if Eval((ar_Size skillUseInc) < 1)
	; 		; If use increment was not added in an earlier foreach, then add it now with the current calculated use experience values for Attribute Protection
	; 		let skillUseInc["skillCode"] := useOverride["skillCode"]
	; 		let skillUseInc["useIncs"] := ar_Construct "Array"
	; 		let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
	; 		let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
	; 		let skillUseInc["reasons"] := ar_Construct "Array"
	; 		let skillUseInc["reasons"][0] := Recurved.OverrideReasonAttributeGuard
	; 		ar_Append skillUseIncs skillUseInc
	; 	else
	; 		; If use increment was added in an earlier foreach, then apply the Attribute Protection use modifiers to the existing modified use experience amounts
	; 		let skillUseInc["useIncs"][0] := skillUseInc["useIncs"][0] * useOverride["useIncModifiers"][0]
	; 		let skillUseInc["useIncs"][1] := skillUseInc["useIncs"][1] * useOverride["useIncModifiers"][1]
	; 		ar_Append skillUseInc["reasons"] Recurved.OverrideReasonAttributeGuard
	; 	endif
	; 	let o += 1
	; loop

	; ;; Failsafe Overrides
	; set o to 0
	; let ruseOverrides := call rcvFindSkillUseOverrides useOverrides Recurved.OverrideReasonFailsafe
	; DebugPrint "recurve: Found %g AttributeFailsafe exp overrides." (ar_Size ruseOverrides)
	; while (o < ar_Size ruseOverrides)
	; 	let useOverride := ruseOverrides[o]
	; 	let skillUseInc := ar_Construct "StringMap"
	; 	set i to 0
	; 	; foreach (useIncKvp <- skillUseIncs)
	; 	while (i < ar_Size skillUseIncs)
	; 		if Eval(skillUseIncs[i]["skillCode"] == useOverride["skillCode"])
	; 			let skillUseInc := skillUseIncs[i]
	; 		endif
	; 		let i += 1
	; 	loop
	; 	if Eval((ar_Size skillUseInc) < 1)
	; 		; If use increment was not added in an earlier foreach, then add it now with the current calculated use experience values for Attribute Protection
	; 		let skillUseInc["skillCode"] := useOverride["skillCode"]
	; 		let skillUseInc["useIncs"] := ar_Construct "Array"
	; 		let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
	; 		let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
	; 		let skillUseInc["reasons"] := ar_Construct "Array"
	; 		let skillUseInc["reasons"][0] := Recurved.OverrideReasonFailsafe
	; 		ar_Append skillUseIncs skillUseInc
	; 	else
	; 		; If use increment was added in an earlier foreach, then apply the Attribute Protection use modifiers to the existing modified use experience amounts
	; 		let skillUseInc["useIncs"][0] := skillUseInc["useIncs"][0] * useOverride["useIncModifiers"][0]
	; 		let skillUseInc["useIncs"][1] := skillUseInc["useIncs"][1] * useOverride["useIncModifiers"][1]
	; 		ar_Append skillUseInc["reasons"] Recurved.OverrideReasonFailsafe
	; 	endif
	; 	let o += 1
	; loop

	; set i to 0
	; set o to 0
	; let ruseOverrides := call rcvFindSkillUseOverrides useOverrides Recurved.OverrideReasonOverlevel
	; DebugPrint "recurve: Found %g Overlevel exp overrides." (ar_Size ruseOverrides)
	; ; foreach (useKvp <- ruseOverrides)
	; ; 	let useOverride := useKvp["value"]
	; while (o < ar_Size ruseOverrides)
	; 	let useOverride := ruseOverrides[o]
	; 	let skillUseInc := ar_Construct "StringMap"
	; 	foreach (useIncKvp <- skillUseIncs)
	; 		if Eval(useIncKvp["value"]["skillCode"] == useOverride["skillCode"])
	; 			let skillUseInc := useIncKvp["value"]
	; 		endif
	; 	loop
	; 	if Eval((ar_Size skillUseInc) < 1)
	; 		; If use increment was not added in an earlier foreach, then add it now.
	; 		let skillUseInc["skillCode"] := useOverride["skillCode"]
	; 		ar_Append skillUseIncs skillUseInc
	; 	endif
	; 	; regardless of whether or not the skill was already added, overwrite previous modifications with overlevel mods
	; 	let skillUseInc["useIncs"] := ar_Construct "Array"
	; 	let skillUseInc["reasons"] := ar_Construct "Array"
	; 	let skillUseInc["useIncs"][0] := useOverride["useInc"][0]
	; 	let skillUseInc["useIncs"][1] := useOverride["useInc"][1]
	; 	let skillUseInc["reasons"][0] := Recurved.OverrideReasonOverlevel
	; 	let o += 1
	; loop

; 	; Finally apply the calculated experience use increments
; 	set o to 0
; 	DebugPrint "recurve: Applying %g use increment experience overrides." (ar_Size skillUseIncs)
; 	; foreach (useKvp <- skillUseIncs)
; 	; 	let skillUseInc := useKvp["value"]
; 	while (o < ar_Size skillUseIncs)
; 		let skillUseInc := skillUseIncs[o]
; 		SetSkillUseIncrementC skillUseInc["useIncs"][0] skillUseInc["skillCode"] 0
; 		SetSkillUseIncrementC skillUseInc["useIncs"][1] skillUseInc["skillCode"] 1
; 		set i to 0
; 		while (i < ar_Size skillUseInc["reasons"])
; 			if (i == 0)
; 				let useReasons := sv_Construct "%g" (skillUseInc["reasons"][i])
; 			else
; 				let useReasons := sv_Construct "%z, %g" useReasons (skillUseInc["reasons"][i])
; 			endif
; 			let i += 1
; 		loop
; 		let o += 1
; 		DebugPrint "recurve: Overrode skill %g use increments for reason(s) %z. Set useInc0=%.4f, useInc1=%.4f." (skillUseInc["skillCode"]) useReasons (skillUseInc["useIncs"][0]) (skillUseInc["useIncs"][1])
; 		sv_Destruct useReasons
; 	loop
; 	set o to 0
; 	set i to 0
; End