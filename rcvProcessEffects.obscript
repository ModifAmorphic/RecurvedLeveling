scn rcvProcessEffects

int i
array_var overrides
array_var softCapSkills
array_var skillCodes
int effectType
short shouldContinue
;inputs
short forceRefresh
Begin _Function { forceRefresh }
	; Check if Recurved Effects have been disabled or refresh is forced then
	; remove any all effects if any were added previously
	if (Recurved.RecurvedEffectsDisabled || forceRefresh == 1)
		if (RecurvedMessenger.IsEffectsAdded)
			set RecurvedMessenger.IsEffectsAdded to 0
			let skillCodes := ar_Construct "Array"
			call rcvUpdateEffects skillCodes RecurvedMessenger.EffectFailsafe
			call rcvUpdateEffects skillCodes RecurvedMessenger.EffectSoftcap
		endif
		; Return for both disabled or forceRefreshes. Removing and adding spell in same pass 
		; doesn't correctly register the spell.
		return
	endif

	; Check if there's been any level up or skill up events since the last time we checked
	let shouldContinue := call rcvHasEventAfter Recurved.EventTypeSkillChange RecurvedMessenger.LastEffectCheckTick
	if (shouldContinue == 0)
		let shouldContinue := call rcvHasEventAfter Recurved.EventTypeLevelUp RecurvedMessenger.LastEffectCheckTick
	endif
	set RecurvedMessenger.LastEffectCheckTick to RecurvedController.GlobalTick
	if (shouldContinue == 0 && forceRefresh == 0)
		return
	endif

	; Add effect when attribute protection is first enabled (experience requirements for an attribute's major skills is increased exponentially)
	if (Recurved.AttributeProtectionDisabled == 0)

		let overrides := call rcvFindSkillUseOverrides Recurved.SkillUseOverrides Recurved.OverrideReasonAttributeProtection
		set i to 0
		if Eval ((ar_Size overrides) > 0)
			let skillCodes := ar_Construct "Array"
			while (i < ar_Size overrides)
				ar_Append skillCodes overrides[i]["skillCode"]
				let i += 1
			loop
			set effectType to RecurvedMessenger.EffectAttributeProtection
			if (Recurved.AttributeFailsafeEnabled)
				set effectType to RecurvedMessenger.EffectFailsafe
			endif
			call rcvUpdateEffects skillCodes effectType
			set RecurvedMessenger.IsEffectsAdded to 1
			set RecurvedMessenger.IsAttributeEffectsAdded to 1
		elseif (RecurvedMessenger.IsAttributeEffectsAdded)
			; if no overrides then remove any effects if they were added previously
			let skillCodes := ar_Construct "Array"
			call rcvUpdateEffects skillCodes RecurvedMessenger.EffectFailsafe
			set RecurvedMessenger.IsAttributeEffectsAdded to 0
			DebugPrint "recurve: Removed all Attribute Protection / Failsafe effects."
		endif
	endif
	set i to 0

	; Add effect for any minor skill that is currently at or over its softcap
	if (Recurved.MinorSkillSoftCapsDisabled == 0)
		let softCapSkills := call rcvFindSkillsSoftCapped
		if Eval((ar_Size softCapSkills) > 0)
			let skillCodes := ar_Construct "Array"
			while (i < ar_Size softCapSkills)
				ar_Append skillCodes softCapSkills[i]["skillCode"]
				let i += 1
			loop
			call rcvUpdateEffects skillCodes RecurvedMessenger.EffectSoftcap
			set RecurvedMessenger.IsEffectsAdded to 1
			set RecurvedMessenger.IsSoftcapEffectsAdded to 1
		elseif (RecurvedMessenger.IsSoftcapEffectsAdded)
			; if no softcaps then remove any effects if they were added previously
			let skillCodes := ar_Construct "Array"
			call rcvUpdateEffects skillCodes RecurvedMessenger.EffectSoftcap
			set RecurvedMessenger.IsSoftcapEffectsAdded to 0
			DebugPrint "recurve: Removed all soft cap effects."
		endif
	endif
	set i to 0

End