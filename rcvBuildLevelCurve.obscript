scn rcvBuildLevelCurve
; TODO: remove level param? skills are only available for the current level. Either that or move the current level stuff over to GetCurrentLevel

; locals
int startLevel1
int startLevel2
int startLevel3
int startLevel4
int startLevel5
int maxAttributeUp
int skillsForLevelUp

; softcap variables
int i
int skillCode
int skillAmount
int softCap

int inc1
int inc2
int inc3

float capUseInc1
float capUseInc2

array_var skills
array_var levelCurve

; magicka cost vars
float fMagicCasterSkillCostBase
float fMagicCasterSkillCostMult
int skillLevel

; Normalized Weapon DPS
ref weapon
float weaponDamage
float weaponSpeed

ref bowWeapon
float bowDamage
float bowSpeed

; fatigue use
float fatigueUse
;; athletics fatigue settings
float fFatigueAttackWeaponBase 
float fFatigueAttackMult
float fPowerAttackFatiguePenalty
float weaponWeight
;; acrobatics fatigue settings
float fFatigueJumpBase
float fFatigueJumpMult
float fPerkJumpFatigueExpertMult

; input params
int level
Begin _Function { level } 
	let levelCurve := ar_Construct "StringMap"
	
	; Subtract one from starting levels because we want to display and calculate towards the
	; next level
	let startLevel1 := call rcvSubtractOrMin Recurved.Tier1StartLevel 1 1
	let startLevel2 := call rcvSubtractOrMin Recurved.Tier2StartLevel 1 (Recurved.Tier1StartLevel + 1)
	let startLevel3 := call rcvSubtractOrMin Recurved.Tier3StartLevel 1 (Recurved.Tier2StartLevel + 1)
	let startLevel4 := call rcvSubtractOrMin Recurved.Tier4StartLevel 1 (Recurved.Tier3StartLevel + 1)
	let startLevel5 := call rcvSubtractOrMin Recurved.Tier5StartLevel 1 (Recurved.Tier4StartLevel + 1)
	
	;DebugPrint "Start1: %g, Start2: %g, Start3: %g, level: %g" startLevel1 startLevel2 startLevel3 level
	if (level >= startLevel1) && (level < startLevel2)
		set maxAttributeUp to Recurved.Tier1MaxAttributeUp
		set skillsForLevelUp to Recurved.Tier1LevelUpSkillIncs
		let levelCurve["MajorAttributeBonus"] := Recurved.Tier1MajorAttributeBonus
		let levelCurve["SecondaryAttributeBonus"] := Recurved.Tier1SecondaryAttributeBonus
		let levelCurve["startLvl"] := Recurved.Tier1StartLevel
		let levelCurve["endLvl"] := startLevel2
		let levelCurve["EnduranceNormalizeAmount"] := Recurved.Tier1EnduranceNormalizeAmount
		let levelCurve["OverageProtectionExponent"] := Recurved.Tier1OverageProtectionExponent
	elseif (level >= startLevel2) && (level < startLevel3)
		set maxAttributeUp to Recurved.Tier2MaxAttributeUp
		set skillsForLevelUp to Recurved.Tier2LevelUpSkillIncs
		let levelCurve["MajorAttributeBonus"] := Recurved.Tier2MajorAttributeBonus
		let levelCurve["SecondaryAttributeBonus"] := Recurved.Tier2SecondaryAttributeBonus
		let levelCurve["startLvl"] := Recurved.Tier2StartLevel
		let levelCurve["endLvl"] := startLevel3
		let levelCurve["EnduranceNormalizeAmount"] := Recurved.Tier2EnduranceNormalizeAmount
		let levelCurve["OverageProtectionExponent"] := Recurved.Tier2OverageProtectionExponent
	elseif (level >= startLevel3) && (level < startLevel4)
		set maxAttributeUp to Recurved.Tier3MaxAttributeUp
		set skillsForLevelUp to Recurved.Tier3LevelUpSkillIncs
		let levelCurve["MajorAttributeBonus"] := Recurved.Tier3MajorAttributeBonus
		let levelCurve["SecondaryAttributeBonus"] := Recurved.Tier3SecondaryAttributeBonus
		let levelCurve["startLvl"] := Recurved.Tier3StartLevel
		let levelCurve["endLvl"] := startLevel4
		let levelCurve["EnduranceNormalizeAmount"] := Recurved.Tier3EnduranceNormalizeAmount
		let levelCurve["OverageProtectionExponent"] := Recurved.Tier3OverageProtectionExponent
	elseif (level >= startLevel4) && (level < startLevel5)
		set maxAttributeUp to Recurved.Tier4MaxAttributeUp
		set skillsForLevelUp to Recurved.Tier4LevelUpSkillIncs
		let levelCurve["MajorAttributeBonus"] := Recurved.Tier4MajorAttributeBonus
		let levelCurve["SecondaryAttributeBonus"] := Recurved.Tier4SecondaryAttributeBonus
		let levelCurve["startLvl"] := Recurved.Tier4StartLevel
		let levelCurve["endLvl"] := startLevel4
		let levelCurve["EnduranceNormalizeAmount"] := Recurved.Tier4EnduranceNormalizeAmount
		let levelCurve["OverageProtectionExponent"] := Recurved.Tier4OverageProtectionExponent
	elseif (level >= startLevel5)
		set maxAttributeUp to Recurved.Tier5MaxAttributeUp
		set skillsForLevelUp to Recurved.Tier5LevelUpSkillIncs
		let levelCurve["MajorAttributeBonus"] := Recurved.Tier5MajorAttributeBonus
		let levelCurve["SecondaryAttributeBonus"] := Recurved.Tier5SecondaryAttributeBonus
		let levelCurve["startLvl"] := Recurved.Tier4StartLevel
		let levelCurve["endLvl"] := 999
		let levelCurve["EnduranceNormalizeAmount"] := Recurved.Tier5EnduranceNormalizeAmount
		let levelCurve["OverageProtectionExponent"] := Recurved.Tier5OverageProtectionExponent
	else
		set maxAttributeUp to 5
		set skillsForLevelUp to 10
		let levelCurve["MajorAttributeBonus"] := 0
		let levelCurve["SecondaryAttributeBonus"] := 0
		let levelCurve["startLvl"] := level
		let levelCurve["endLvl"] := 999
		let levelCurve["EnduranceNormalizeAmount"] := 5
		let levelCurve["OverageProtectionExponent"] := 1
	endif

	DebugPrint "recurve: Calculating iLevelUpXXMult attribute gains with a max of %g for player level %g. %g skills are required for level up" maxAttributeUp level skillsForLevelUp
	let inc3 := call rcvSubtractOrMin maxAttributeUp 1 2
	let inc2 := call rcvSubtractOrMin inc3 1 2
	let inc1 := call rcvSubtractOrMin (maxAttributeUp / 2) 1 2

	let levelCurve["iLevelUpMults"] := ar_Construct "Array"
	let i := 0
	while (i < 9)
		let levelCurve["iLevelUpMults"][i] := ar_Construct "StringMap"
		;let levelCurve["iLevelUpMults"][i]["setting"] := sv_Construct "iLevelUp0%gMult" (i + 1)
		if i < 3 ; iLevelUpMults 1-3
			let levelCurve["iLevelUpMults"][i]["value"] := inc1
		elseif i < 6 ; iLevelUpMults 4-6
			let levelCurve["iLevelUpMults"][i]["value"] := inc2
		elseif i < 9 ; iLevelUpMults 7-9
			let levelCurve["iLevelUpMults"][i]["value"] := inc3
		endif
		let i += 1
	loop
	; Finally, set iLevelUp10Mult to the max
	let levelCurve["iLevelUpMults"][9] := ar_Construct "StringMap"
	; let levelCurve["iLevelUpMults"][9]["setting"] := "iLevelUp10Mult"
	let levelCurve["iLevelUpMults"][9]["value"] := maxAttributeUp
	
	; Major skill increases required for new level
	let levelCurve["iLevelUpSkillCount"] := skillsForLevelUp
	
	; Configure Current Skill Softcaps
	;; We divide the experience gained per skill use by the Recurved.SoftCapMulti to multiply 
	;; the amount of experience needed per skill level.
	let skills := call rcvGetSkills
	let levelCurve["skills"] := ar_Construct "Array"
	set i to 0
	while (i < ar_size skills["minor"])
		let skillCode := skills["minor"][i]["code"]
		let softCap := skills["minor"][i]["softCap"]
		let skillAmount := skills["minor"][i]["amount"]
		let capUseInc1 := (call rcvGetDefaultSkillUseInc skillCode 0)
		let capUseInc2 := (call rcvGetDefaultSkillUseInc skillCode 1)
		if Recurved.MinorSkillSoftCapsDisabled == 0
			let capUseInc1 := call rcvCalculateUseIncrement capUseInc1 Recurved.SoftCapMulti
			let capUseInc2 := call rcvCalculateUseIncrement capUseInc2 Recurved.SoftCapMulti
		endif
		let levelCurve["skills"][i] := ar_Construct "StringMap"
		let levelCurve["skills"][i]["skillCode"] := skillCode
		let levelCurve["skills"][i]["softCapLvl"] := softCap
		let levelCurve["skills"][i]["softCapMulti"] := Recurved.SoftCapMulti
		let levelCurve["skills"][i]["useInc"] := ar_Construct "Array"
		let levelCurve["skills"][i]["useInc"][0] := (call rcvGetDefaultSkillUseInc skillCode 0)
		let levelCurve["skills"][i]["useInc"][1] := (call rcvGetDefaultSkillUseInc skillCode 0)
		let levelCurve["skills"][i]["softCapEnabled"] := Recurved.MinorSkillSoftCapsDisabled == 0 && skillAmount >= softCap
		let levelCurve["skills"][i]["softCapUseInc"] := ar_Construct "Array"
		let levelCurve["skills"][i]["softCapUseInc"][0] := capUseInc1
		let levelCurve["skills"][i]["softCapUseInc"][1] := capUseInc2
		DebugPrint "Setting levelCurve['skills'][%g]['baseExpReq'] = %.2f" skills["all"][skillCode]["baseExpReq"]
		let levelCurve["skills"][i]["baseExpReq"] := skills["all"][skillCode]["baseExpReq"]
		let i += 1
		set capUseInc1 to 0
		set capUseInc2 to 0
	Loop
	set i to 0

	set fMagicCasterSkillCostBase to GetGameSetting "fMagicCasterSkillCostBase"
	set fMagicCasterSkillCostMult to GetGameSetting "fMagicCasterSkillCostMult"
	let levelCurve["magicSchools"] := ar_Construct "Array"
	DebugPrint "recurve: Calculating magicka cost multiplier for all magic schools for character level %g." level
	while (i < 6)
		let skillLevel := skills["all"][i + 20]["amount"]
		let levelCurve["magicSchools"][i] := ar_Construct "StringMap"
		let levelCurve["magicSchools"][i]["magickaCostMult"] := fMagicCasterSkillCostBase + (fMagicCasterSkillCostMult * (1 - (skillLevel / 100)))
		if (Recurved.DebugEnabled || Recurved.OutputFormulas)
			PrintToConsole "recurve: Calculated magicka cost multiplier for school %g (skill %g)." i (i + 20)
			PrintToConsole "recurve: Formula: magickaCostMult = fMagicCasterSkillCostBase + (fMagicCasterSkillCostMult * (1 - (skillLevel / 100)))"
			PrintToConsole "recurve:  Result: %.4f = %.2f + (%.2f * (1 - (%g / 100)))" levelCurve["magicSchools"][i]["magickaCostMult"] fMagicCasterSkillCostBase fMagicCasterSkillCostMult skillLevel
		endif
		let i += 1
	loop
	set i to 0
	;; Calculate Weapon Exp for normalized to DPS
	if (Recurved.WeaponExpNormalizedDisabled == 0)
		if (level < 4)
			set weapon to WeapIronDaggerRusty
			set bowWeapon to WeapIronBow
		elseif (level < 9)
			set weapon to WeapIronDagger
			set bowWeapon to WeapIronBow
		elseif (level < 12)
			set weapon to WeapIronDaggerFine
			set bowWeapon to WeapIronBowFine
		elseif (level < 16)
			set weapon to WeapSteelDagger
			set bowWeapon to WeapSteelBow
		else
			set weapon to WeapSilverDagger
			set bowWeapon to WeapSilverBow
		endif
		; 	set weapon to WeapElvenDagger
		; 	set bowWeapon to WeapElvenBow
		; endif
		
		let levelCurve["normalizedWeaponExp"] := ar_Construct "StringMap"

		set weaponDamage to GetAttackDamage weapon
		set weaponSpeed to GetWeaponSpeed weapon
		let levelCurve["normalizedWeaponExp"]["melee"] := ar_Construct "StringMap"
		let levelCurve["normalizedWeaponExp"]["melee"]["damage"] := weaponDamage
		let levelCurve["normalizedWeaponExp"]["melee"]["speed"] := weaponSpeed
		let levelCurve["normalizedWeaponExp"]["melee"]["dps"] := weaponSpeed * weaponDamage
		let levelCurve["normalizedWeaponExp"]["melee"]["weapon"] := weapon

		set bowDamage to GetAttackDamage bowWeapon
		set bowSpeed to GetWeaponSpeed bowWeapon ;bow speed is the same for all vanilla bows, but doesn't hurt to use it
		if (level < 4)
			; Reduce to 60% of iron damage since the rusty iron bow is the same damage/dps
			let bowDamage *= .6
		endif
		let levelCurve["normalizedWeaponExp"]["bow"] := ar_Construct "StringMap"
		let levelCurve["normalizedWeaponExp"]["bow"]["damage"] := bowWeapon
		let levelCurve["normalizedWeaponExp"]["bow"]["speed"] := bowSpeed * bowDamage
		let levelCurve["normalizedWeaponExp"]["bow"]["dps"] := weaponSpeed * weaponDamage
		let levelCurve["normalizedWeaponExp"]["bow"]["weapon"] := bowWeapon
	endif

	let levelCurve["actionFatigueUse"] := ar_Construct "Array"
	while (i <= Recurved.ActionCombatDodge)
		let levelCurve["actionFatigueUse"][i] := -1
		let i += 1
	loop
	
	;; Precalculate fatigue use if possible to avoid having to do it on every action.
	;;; Left out block and bow since they don't use fatigue after hitting novice and didn't seem worth the effort
	;;; TODO: Add spellcasts? Fatigue usage is really low. Might not be worth bothering with the fatigue check (or precheck)
	if (Recurved.AthleticsActionsExpDisabled == 0 || Recurved.AcrobaticsActionsExpDisabled == 0)
		set weapon to Player.GetEquippedObject 16
		if (weapon)
			; Set fatigue use for melee weapons
			if Eval((GetWeaponType weapon) < 5)
				set weaponWeight to GetWeight weapon
				set fFatigueAttackWeaponBase to GetGameSetting "fFatigueAttackWeaponBase"
				set fFatigueAttackMult to GetGameSetting "fFatigueAttackWeaponMult"
				set fPowerAttackFatiguePenalty to GetGameSetting "fPowerAttackFatiguePenalty"
				let levelCurve["actionFatigueUse"][Recurved.ActionAttack] := (fFatigueAttackWeaponBase + fFatigueAttackMult * weaponWeight)
				let levelCurve["actionFatigueUse"][Recurved.ActionPowerAttack] := (fFatigueAttackWeaponBase + fFatigueAttackMult * weaponWeight) * fPowerAttackFatiguePenalty
				; Use weapon attack fatigue for calculating jump attack usage since the "jump" part is already removed from total fatigue
				;; by the time we check for a "jump attack"
				let levelCurve["actionFatigueUse"][Recurved.ActionJumpAttack] := levelCurve["actionFatigueUse"][Recurved.ActionAttack]
			endif
		endif
	endif
	if (Recurved.AcrobaticsActionsExpDisabled == 0)
		; fFatigueJumpMult is 0 in vanilla so we may be able to precalculate the fatigue use unless the value has been modded
		set fFatigueJumpMult to GetGameSetting "fFatigueJumpMult"
		if (fFatigueJumpMult == 0)
			set fFatigueJumpBase to GetGameSetting "fFatigueJumpBase"
			set fPerkJumpFatigueExpertMult to 1
			; Only get acrobatics expert perk value if expert level or higher, otherwise leave at 1
			if Eval(skills["all"][26]["amount"] > 74)
				set fPerkJumpFatigueExpertMult to GetGameSetting "fPerkJumpFatigueExpertMult"
			endif
			set fatigueUse to fFatigueJumpBase * fPerkJumpFatigueExpertMult
			let levelCurve["actionFatigueUse"][Recurved.ActionCombatDodge] := fFatigueJumpBase * fPerkJumpFatigueExpertMult
		endif
	endif

	SetFunctionValue levelCurve
End