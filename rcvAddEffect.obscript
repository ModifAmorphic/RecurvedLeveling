; Works but requires completely hijacking a magic effect
scn rcvAddEffect

int i
array_var recurvedEffect
short spellExists
string_var spellName
ref magicEffect
array_var trackedEffect
int effectIndex
int attributeCode
;debugging
string_var formId

; inputs
int skillCode
int effectType
; outputs
ref recurvedSpell
Begin _Function{ skillCode effectType }
	
	let magicEffect := MagicEffectFromChars Recurved.MagicEffectDisplayAbbr
	set spellExists to 0
	while (i < ar_Size RecurvedMessenger.Effects[effectType])
		let recurvedEffect := RecurvedMessenger.Effects[effectType][i]
		if Eval(recurvedEffect["skillCode"] == skillCode)
			set spellExists to 1
			let recurvedSpell := recurvedEffect["spell"]
			let recurvedEffect["active"] := 1
			DebugPrint "recurve: Found existing spell %q%n%q for effectType %g at index %g." recurvedEffect["spell"] effectType i
			break
		endif
		let i += 1
	loop

	; Set the spell name depending on the effect type
	if (effectType == RecurvedMessenger.EffectSoftcap)
		let spellName := (ActorValueToStringC skillCode) + " progress slowed (Softcap)"
	elseif (effectType == RecurvedMessenger.EffectAttributeGuard)
		let spellName := (ActorValueToStringC skillCode) + " progress slowed (Attribute Guard)"
	elseif (effectType == RecurvedMessenger.EffectAttributesFailsafe)
		let spellName := (ActorValueToStringC skillCode) + " progress halted (Failsafe)"
	elseif (effectType == RecurvedMessenger.EffectOverlevel)
		let spellName := (ActorValueToStringC skillCode) + " progress halted (Overleveled)"
	endif

	if (spellExists == 0)
		; Clone the existing Recurved Spell, rename it and track it for future use
		let recurvedSpell := CloneForm rcvSkillExpPenalty
		let trackedEffect := ar_Construct "StringMap"
		let trackedEffect["skillCode"] := skillCode
		let trackedEffect["active"] := 1
		let trackedEffect["spell"] := recurvedSpell
		ar_Append RecurvedMessenger.Effects[effectType] trackedEffect
		set effectIndex to AddFullEffectItem magicEffect 0 0 0 0 recurvedSpell
		let formId := GetFormIDString recurvedSpell
		DebugPrint "recurve: Created new spell %n (%z) with effect %n for skillCode %g and effect type %g. RecurvedMessenger.Effects size is %g." recurvedSpell formId magicEffect skillCode effectType (ar_Size RecurvedMessenger.Effects)
	elseif Eval((MagicItemHasEffect Recurved.MagicEffectDisplayAbbr recurvedSpell) == 0)
		RemoveAllEffectItems recurvedSpell
		set effectIndex to AddFullEffectItem magicEffect 0 0 0 0 recurvedSpell
	endif
	SetName spellName recurvedSpell
	; If magic effect is a drain effect, then set the actor value appropriately
	; so the spell gets grouped under the appropriate drain
	if (magicEffect == DRSK)
		DebugPrint "recurve: Setting spell %q%n%q magic effect to use skill code %g" recurvedSpell skillCode
		SetNthEffectItemActorValueC skillCode recurvedSpell 0
	elseif (magicEffect == DRAT)
		let attributeCode := GetSkillGoverningAttributeC skillCode
		DebugPrint "recurve: Setting spell %q%n%q magic effect to use attribute code %g" recurvedSpell attributeCode
		SetNthEffectItemActorValueC attributeCode recurvedSpell 0
	endif
	let formId := GetFormIDString recurvedSpell
	; finally, add the spell
	;; If a forced refresh, then silently add the spell
	if (RecurvedMessenger.ForceEffectsRefresh)
		player.AddSpellNS recurvedSpell
	else
		player.AddSpell recurvedSpell
	endif
	DebugPrint "recurve: Added spell %n (%z) with effect %n for skillCode %g and effect type %g to player." recurvedSpell formId magicEffect skillCode effectType
	sv_Destruct formId
	sv_Destruct spellName
	SetFunctionValue recurvedSpell
End