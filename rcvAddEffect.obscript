; Works but requires completely hijacking a magic effect
scn rcvAddEffect

int i
array_var recurvedEffect
short spellExists
string_var spellName
ref magicEffect
array_var trackedEffect
int effectIndex
int attributeCode
;debugging
string_var formId

; inputs
int skillCode
int effectType
; outputs
ref recurvedSpell
Begin _Function{ skillCode effectType }
	
	let magicEffect := MagicEffectFromChars Recurved.MagicEffectDisplayAbbr
	set spellExists to 0
	while (i < ar_Size RecurvedMessenger.Effects[effectType])
		let recurvedEffect := RecurvedMessenger.Effects[effectType][i]
		if Eval(recurvedEffect["skillCode"] == skillCode)
			set spellExists to 1
			let recurvedSpell := recurvedEffect["spell"]
			let recurvedEffect["active"] := 1
			;DebugPrint "recurve: Adding existing spell %n to player." recurvedEffect["spell"]
			break
		endif
		let i += 1
	loop

	if (spellExists == 0)
		; If spell needs to be created, then go through all the setup
		; Set the spell name depending on the effect type
		if (effectType == RecurvedMessenger.EffectFailsafe)
			let spellName := (ActorValueToStringC skillCode) + " progress stopped"
		elseif (effectType == RecurvedMessenger.EffectAttributeProtection)
			let spellName := (ActorValueToStringC skillCode) + " progress slowed"
		elseif (effectType == RecurvedMessenger.EffectSoftcap)
			let spellName := (ActorValueToStringC skillCode) + " progress difficult"
		endif

		; Clone the existing Recurved Spell, rename it and track it for future use
		let recurvedSpell := CloneForm rcvSkillExpPenalty
		SetName spellName recurvedSpell
		let trackedEffect := ar_Construct "StringMap"
		let trackedEffect["skillCode"] := skillCode
		let trackedEffect["active"] := 1
		let trackedEffect["spell"] := recurvedSpell
		ar_Append RecurvedMessenger.Effects[effectType] trackedEffect
		set effectIndex to AddFullEffectItem magicEffect 0 0 0 0 recurvedSpell
	elseif Eval((MagicItemHasEffect Recurved.MagicEffectDisplayAbbr recurvedSpell) == 0)
		RemoveAllEffectItems recurvedSpell
		set effectIndex to AddFullEffectItem magicEffect 0 0 0 0 recurvedSpell
	endif

	; If magic effect is a drain effect, then set the actor value appropriately
	; so the spell gets grouped under the appropriate drain
	if (magicEffect == DRSK)
		DebugPrint "recurve: Setting spell %q%n%q magic effect to use skill code %g" recurvedSpell skillCode
		SetNthEffectItemActorValueC skillCode recurvedSpell 0
	elseif (magicEffect == DRAT)
		let attributeCode := GetSkillGoverningAttributeC skillCode
		DebugPrint "recurve: Setting spell %q%n%q magic effect to use attribute code %g" recurvedSpell attributeCode
		SetNthEffectItemActorValueC attributeCode recurvedSpell 0
	endif
	let formId := GetFormIDString recurvedSpell
	; finally, add the spell
	;; If a forced refresh, then silently add the spell
	if (RecurvedMessenger.ForceEffectsRefresh)
		player.AddSpellNS recurvedSpell
	else
		player.AddSpell recurvedSpell
	endif
	DebugPrint "recurve: Added spell %n (%z) with effect %n for skillCode %g and effect type %g to player." recurvedSpell formId magicEffect skillCode effectType
	sv_Destruct formId
	sv_Destruct spellName
	SetFunctionValue recurvedSpell
End