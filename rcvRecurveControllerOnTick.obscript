scn rcvRecurveControllerOnTick ; Called on every fQuestDelayTime "tick" of the GameMode

int prunedEvents

;inputs
short isGameRestarted
short isGameLoaded
; outputs
short hasUpdate
Begin _Function { isGameRestarted isGameLoaded }
	set RecurvedController.GlobalTick to RecurvedController.GlobalTick + 1
	; load ini and set constants on load
	if isGameLoaded
		call rcvSetConstants
		call rcvLoadIni
		call rcvSetConstants ; set constants again to insure they're still set as expected after loading the ini
	endif
	
	; Preserve load and restart statuses for later
	; if the tutorial is active
	if RecurvedController.IsTutorialComplete || isGameRestarted
		set RecurvedController.hasRestartedSinceUpdate to isGameRestarted
	endif
	if RecurvedController.IsTutorialComplete || isGameLoaded
		set RecurvedController.hasLoadedSinceUpdate to isGameLoaded
	endif

	; Run any debug commands that may be pending
	if Recurved.DebugEnabled
		call rcvDebugRunCommands
	endif

	if (RecurvedController.GlobalTick - RecurvedController.lastEventPurge > Recurved.EventExpirationTicks && RecurvedController.hasLoadedSinceUpdate == 0)
		let prunedEvents := call rcvPruneEvents 0
		set RecurvedController.lastEventPurge to RecurvedController.GlobalTick
	endif
	
	set RecurvedController.fQuestDelayTime to Recurved.RecurvedControllerInterval
	
	; If tutorial is not yet flagged as complete, then check to see if that's changed
	if (RecurvedController.IsTutorialComplete == 0)
		let RecurvedController.IsTutorialComplete := !(call rcvGetIsInTutorial isGameLoaded)
		; if (RecurvedController.IsTutorialComplete == 0)
		; 	return  ; Exit early if still in tutorial!!
		; endif
	endif
	;;; End Tutorial Check

	; Only mark update if new updates or game loads
	if RecurvedController.hasLoadedSinceUpdate || RecurvedController.UpdateFlag
		if (RecurvedController.IsTutorialComplete)
			set hasUpdate to 1
		endif
	endif

	SetFunctionValue hasUpdate
End