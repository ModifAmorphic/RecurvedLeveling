scn rcvUpdateAttributeGuards

; Overage prevention
float skillIncsForMaxAttrib ; skill increases required for a maximized attribute bonus

int i
int attributeCode
int secondaryAttrbCode
int progressPoints
int lvlProgress
int addLvlProgress
int maxLvlProgress
short isMajorSkill
short isProtectionApplied
short isAttributeMaxed
array_var maxedAttrProgress
array_var maxedAttributes
int maxedAttrProgressCount
int maxedAttributesCount
int unmaxedAttributes
int maxedAttrProgressReq
array_var levelCurve
array_var cappedSkills
array_var limitedSkills
int removedGuards

; inputs
int skillCode       ; Actor value code for the skill
int skillIncrease   ; Increase to the skill that will be applied

; output
int skillsCapped
Begin _Function { skillCode skillIncrease } ; Checks for potential Attribute progress overage and slows down Major Skills if found
	set skillsCapped to 0
	
	; if disabled, ensure any existing protections are removed then get out of here
	if Recurved.AttributeGuardDisabled
		let removedGuards := call rcvDeleteSkillOverrides Recurved.OverrideReasonFailsafe
		let removedGuards += call rcvDeleteSkillOverrides Recurved.OverrideReasonAttributeGuard
		let skillsCapped -= removedGuards
		SetFunctionValue skillsCapped
		DebugPrint "recurve: Removed %g skill use overrides due to Attribute Guard being disabled." removedGuards
		return
	endif

	set isMajorSkill to player.IsClassSkillC skillCode
	set attributeCode to GetSkillGoverningAttributeC skillCode
	let secondaryAttrbCode := Recurved.AttributeSecondaries[attributeCode]
	let levelCurve := call rcvGetLevelCurve player.GetLevel 0 0

	DebugPrint "recurve: Attribute Guard processing started for Attribute %g, Secondary Attribute %g, Skill: %g, SkillIncrease: %g." attributeCode secondaryAttrbCode skillCode skillIncrease
	; Get a list of attributes whose progress is maxed (or will be maxed with this increase)
	let maxedAttrProgress := ar_Construct "Array"
	let maxedAttributes := call rcvGetMaxedAttributes 0
	set i to 0
	while (i < 7)
		let isAttributeMaxed := (ar_Find i maxedAttributes) >= 0
		; if Eval((ar_Find i maxedAttributes) >= 0)
		; 	DebugPrint "recurve: Excluding maxed attribute %v {%g} from attribute guard calculations." i i
		; 	let i += 1
		; 	continue
		; endif
		set progressPoints to GetPCAttributeBonusC i
		; Add the incoming skill increase
		if (i == attributeCode)
			let progressPoints += skillIncrease
		endif
		; include any bonus, bonus progress if enabled
		if (isMajorSkill && skillIncrease > 0)
			if (Recurved.AttributeBonusDisabled == 0 && i == attributeCode)
				let progressPoints += levelCurve["MajorAttributeBonus"]
			endif
			if (Recurved.SecondaryAttributesDisabled == 0 && i == secondaryAttrbCode)
				let progressPoints += levelCurve["SecondaryAttributeBonus"]
			endif
		endif
		DebugPrint "recurve: Calculated skill %g's incoming increase of %g will set progress points to %g for attribute %g." skillCode skillIncrease progressPoints i
		if (progressPoints >= 10)
			ar_Append maxedAttrProgress i
			if (isAttributeMaxed == 0)
				set maxedAttrProgressCount to maxedAttrProgressCount + 1
			endif
		elseif (isAttributeMaxed)
			; add maxed out attributes but don't count them 
			ar_Append maxedAttrProgress i
		endif
		let i += 1
	loop
	
	;let maxedAttrProgressCount := (ar_Size maxedAttrProgress)
	DebugPrint "recurve: Found %g attributes whose progress was or will be maxed." maxedAttrProgressCount

	set i to 0
	; If maxed out attribute progress is less than 3, then cap any major skills
	; that will increase the attribute (secondary bonus to attributes not included).
	
	; If Recurved.MinimumMaxedAttributes is set to higher than the number of unmaxed attributes remaining,
	; then lower the amount of maxed attribute progress to the remaining amount.
	let maxedAttributesCount := ar_size maxedAttributes
	set unmaxedAttributes to 7 - maxedAttributesCount
	set maxedAttrProgressReq to Recurved.MinimumMaxedAttributes
	if (unmaxedAttributes < maxedAttrProgressReq)
		DebugPrint "recurve: There are %g remaining unmaxed attributes which is lower than the %g attributes MinimumMaxedAttributes is configured for. Lowering mimimum amount to unmaxed value." unmaxedAttributes Recurved.MinimumMaxedAttributes
		set maxedAttrProgressReq to unmaxedAttributes
	endif
	; Get the current level progress before skill up
	; Add the skill increase to level progress if this is a major skill
	if (isMajorSkill)
		let addLvlProgress := skillIncrease
	endif
	set lvlProgress to GetPCMajorSkillUps + addLvlProgress
	
	; calculate skill increases required to max one attribute
	let skillIncsForMaxAttrib := 10 / (levelCurve["MajorAttributeBonus"] + 1)
	; Enable attribute guard if level progress exceeds or equals the amount of increases 
	;; required to max one attribute and the amount of currently maxed attribute bonuses is less 
	;; than the required amount.
	DebugPrint "recurve: lvlProgress=%g, skillIncsForMaxAttrib=%.2f, maxedAttrProgressCount=%g, maxedAttrProgressReq=%g" lvlProgress skillIncsForMaxAttrib maxedAttrProgressCount maxedAttrProgressReq
	if Eval ((lvlProgress >= (Floor skillIncsForMaxAttrib)) && (maxedAttrProgressCount < maxedAttrProgressReq))
		
		; If character is about to level without reaching 3 maxed attributes, enable attribute leveling failsafe
		let cappedSkills := call rcvAddAttributesFailsafe addLvlProgress

        set maxLvlProgress to GetGameSetting "iLevelUpSkillCount"
		if Eval ((ar_Size cappedSkills) > 0)
			let skillsCapped := ar_Size cappedSkills
			DebugPrint "Leveling failsafe enabled. Only %g of %g Attributes had reached max increase values for the level. Level progress %g/%g" maxedAttrProgressCount maxedAttrProgressReq lvlProgress maxLvlProgress
		else
			; If attribute failsafe not triggered, then apply the progressive guard prevention

			let limitedSkills := call rcvAddAttributeGuards maxedAttrProgress lvlProgress skillIncsForMaxAttrib levelCurve
			let skillsCapped := ar_Size limitedSkills
		endif
		set isProtectionApplied to 1
		call rcvAddEvent Recurved.EventTypeAttributeGuard skillsCapped 0 ar_Null
	endif
	
	if (isProtectionApplied == 0) ; If no protection applied, then unlock any capped skills
		let removedGuards := call rcvDeleteSkillOverrides Recurved.OverrideReasonAttributeGuard
		let skillsCapped -= removedGuards
		DebugPrint "recurve: Removed %g skill use overrides due to overage protection no longer being enforced." removedGuards
	endif
	SetFunctionValue skillsCapped
End